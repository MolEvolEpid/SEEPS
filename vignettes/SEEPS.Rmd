---
title: "SEEPS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SEEPS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
SEEPS provides functionality for large, detailed, stochastic simulations of pathogen outbreaks. While initially developed for HIV, it can be used for any pathogen. Our parameter choices here are taken from HIV-1 models. The workflow of a SEEPS experiment is generally split into four stages:

1. Simulate the pathogen transmission network (e.g. an outbreak) from a single index case.
2. Sample a collection of tips from the transmission network.
3. Extract the subtree. Optionally, process the tree to simulate within-host diversity.
4. Process, export, or analyze the subtree.

## Simulate a transmission network with `gen_transmission_history_exponential_constant`

The first step of a SEEPS simulation is to obtain a transmission history. SEEPS tracks an "active" population of infections and records their ancestral relation (who infected whom and when).

Let's look at the following piece of code and break down the arguments:

``` {r}
set.seed(1947)
offspring_rate_fn <- SEEPS::get_biphasic_HIV_rate(
  params = list("R0" = 5))

# Simulate
transmission_history <- SEEPS::gen_transmission_history_exponential_constant(
  offspring_rate_fn = offspring_rate_fn,
  maximum_population_target = 50,
  minimum_population = 15,
  total_steps = 48,
)
```

SEEPS is structured around two basic simulation modes: an exponential growth phase, and a constant population (maintenance) phase. This simulation function is ideal for cases where all observations are taken at a single point in time. We will explore the full API in [].

### Exponential growth / offspring generation rate

Heterogeneity in the rate of generating secondary infections is a common source of variance. Here, this is user specified. Here, we consider the age of the infection as the primary source of heterogeneity. The exponential growth is encoded by an offspring generation rate function `f`, which determines the expected number of offspring that should be generated by an infection of `x` months old.

For HIV infections, a simple model is the biphasic rate function where the majority of new infections occur in the first 3 months of infection, and then a smaller number of infections occur in the following 21 months. The total density is normalized so $R_0$ infections are obtained over an average total infectious period.

This function encodes the growth rate $R_0$.

SEEPS rate functions are implemented as functions, which accept a vector of ages of all "active" infections, and return a vector of the expected number of offspring per time step. All rate functions should accept a `params` argument that contains any additional constants needed for the rate function. For HIV, we often use the following rate function:

```{r}
ages <- c(1, 2, 5)
offspring_probs <- SEEPS::biphasic_HIV_rate(6, ages, params = list("R0" = 5))
print(offspring_probs)
```

### Maximum target population size

The number of possible offspring is limited by the maximum active population size (`maximum_population_target`). This is a user specified parameter. This value is chosen based on the available computational resources, and desired simulation size to attain a desired sample density. Often, we think of a "sufficiently large" population, so our sample density is small (e.g. taking 15 tips from a population of 1000 cases), or having very good sample density (measured in X% of the population). SEEPS will never simulate more active infections than this quantity.

To avoid a time step during the _exponential growth_ phase where the number of offspring is not consistent with the exponential growth assumptions,
SEEPS simulators will stop at 90% of the maximum population size. This behavior can be adjusted (as we shall see below), but we find 90% to be a good balance between computational efficiency and accuracy.

### Minimum population

In some cases, it is desirable to ensure that our population exceeds a specified minimum:

* A low $R_0$ may result in a premature extinction event.
* A downstream analysis may assume that a minimum number of infections are present.

The parameter `minimum_population` is used to ensure that the population is at least this large, before exiting an exponential growth phase.

### Length of the constant growth phase

Once the exponential growth phase is complete, the population is maintained at a constant size. This models the application of a public health control program which prevents further growth in the number of active cases, but replaces treated infections to maintain the population size. The length of the constant growth phase is specified by `total_steps`.

## Sample a collection of tips

This section provides only a brief overview of the sampling methods available within SEEPS. See the detailed overview of available sampling methods for more details.

The full tree is rarely accessible, only samples from it are ever practically accessible. There are two modes of sampling we suggest for new users: uniform (independent) sampling and (iterative) contact tracing (with restarts). Contact tracing is more expensive, but gives a much more realistic sample.

* Uniform sampling uses `random_ids` and offers additional support for proportional random sampling.
* Iterative contact tracing with restarts uses `contact_traced_uniform_restarts_ids` which accepts the parental histories/transmission times of the full tree, list of active individuals to sample from, and a single parameter `p` that represents the discovery rate of iterative contact tracing. The algorithm is restarted with a new seed until `minimum_sample_size` infections are sampled.

```{r}
sample <- SEEPS::contact_traced_uniform_restarts_ids(
  active = transmission_history$active,
  parents = transmission_history$parents,
  minimum_sample_size = 6,
  p = 0.4
)
```

Contact tracing is a random process, the list `sample` contains both the final sample, but additional information about the sampling process.

```{r}
print(sample)
```

* The `success` flag should be checked to ensure that the sampling process was successful. If `success` is `FALSE`, then the sampling process was not successful, and the sample should be discarded and repeated. Failure usually indicates an issue with the input data structure.
* The `status` attribute reports a human-readable status message. This should not be used for downstream analysis, but is useful for debugging. Use `success` and `group_ids` attributes for downstream analysis.
* The `found` attribute lists both currently active and inactive infections that were sampled discovered/linked via contact tracing. Only active individuals can be sampled and are reported in the `samples` attribute.
* As this algorithm will restart contact tracing with a new index case when no new infections are found, the `group_ids` attribute lists which attempt at contact tracing discovered each individual. This is useful for downstream analysis, as these often are interpreted (sometimes erroneously) as "clusters" of infections.

## Extract the subtree

The full tree is rarely accessable, only samples from it are ever practically accessable. SEEPS offers two methods for extracting a subtree, the end goal is to obtain a phylogeny.

* `reduce_transmission_history` reconstructs the geneology for a sample from the full tree using only the contact network. Edge lengths correspond to times between infections. Transmission chains are not reconstructed along edges.
* `reduce_transmission_history_bpb` reconstructs a more detailed genealogy, recording all transmission events necessary to model the within-host diversity of each host. This function is paired with `geneology_to_phylogeny_bpb` which simulates within host diversity along the genealogy. The `bpb` suffix denotes that this functionality is derived from [BioPhyBreak](https://github.com/MolEvolEpid/biophybreak), a package for simulating within-host diversity.

```{r}
genealogy <- SEEPS::reduce_transmission_history_bpb(
  sample = sample$samples,
  parents = transmission_history$parents,
  current_step = transmission_history$t_end)
print(genealogy)
```

Now we can simulate within host diversity as we know where the transmission events occurred.

```{r, label="within-host"}
phylogeny <- SEEPS::geneology_to_phylogeny_bpb(
  transmission_history = genealogy$parents,
  infection_times = genealogy$transmission_times,
  leaf_sample_ids = genealogy$transformed_sample_indices,
  sample_times = genealogy$sample_times,
  a = 5, b = 5)
# print(phylogeny)
# print(phylogeny[,6])
#print(sum(phylogeny[,6]))
```

This phylogeny list contains 4 fields:

* `names_newick` contains the (relabeled) names of the tips. Includes all unsampled tips.
* `newick_string` contains a newick string of the phylogeny, with the tips labeled using `names_newick`
* `tree` an ape tree representation of the newick string.
* `phylogeny` a phylogeny matrix that encodes the ancestral relationship within the tree. This is the object we want to carry forward for downstream analysis.

## Exporting

### Newick string or ape tree

We can convert the phylogeny to a Newick string and load it into ape to visualize.

```{r}
newick_string <- SEEPS::phylogeny_to_newick(phylogeny$phylogeny,
  mode="mean", label_mode="abs")

tree <- ape::read.tree(text = newick_string)
plot(ape::ladderize(tree))
box("outer")
title(main="Simulated phylogeny for 6 sampled infections",
  xlab="Time from index infection (Months)")
axis(1, col="black", col.ticks="black", col.axis="black", las=1)
```

Most of the tips are unsampled, so we can remove them from the tree and reveal the _discoverable_ relationship between the sequences.

```{r}
tree <- ape::drop.tip(tree, "")  # unsampled tips have no index
plot(ape::ladderize(tree))
box("outer")
title(main="Observable phylogeny for 6 sampled infections",
  xlab="Time from most recent common ancestor (Months)")
axis(1, col="black", col.ticks="black", col.axis="black", las=1)
```

### Pairwise distance matrix

We could alternatively store only the distance relationship between the samples.

```{r}
print(phylogeny$phylogeny)
```

```{r}
mean_distances <- SEEPS::geneology_to_distance_matrix(phylogeny$phylogeny, mode="mean")
print(mean_distances * 0.0067 / 12 * 300)  # subs / (year * site) * months/year * # of sites
```

This matrix can be constructed using either _expected_ or _sampled_ distances. We can sample the distances and update the phylogeny object.
Note that sampling edge lengths results in the tree no longer being [ultametric](https://en.wikipedia.org/wiki/Distance_matrix#Ultrametric_distance_matrix).
```{r}
sampled_phylogeny <- SEEPS::stochastify_transmission_history(
            transmission_history = phylogeny$phylogeny,
            rate = 0.0067 / 12 * 300)  # subs / (year * site) * months/year * # of sites
sampled_distances <- SEEPS::geneology_to_distance_matrix(sampled_phylogeny$geneology, mode="mu")
print(sampled_distances)
```

More details about exporting and other post-processing methods in the [Exporting data vignette](Exporting_data).
